<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <style>
        canvas {
            /* Xóa khung viền của canvas */
            border: none;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <h1>Welcome, {{ user_id }}</h1>

    <div>
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <button id="draw">Draw</button>
        <button id="end-draw">End Draw</button>
    </div>

    <canvas id="imageCanvas"></canvas>

    <script>
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        let drawingMode = false;
        let points = [];
        const threshold = 10;  // Adjust threshold value as needed

        function loadImage() {
            fetch('/get-image')
                .then(response => response.blob())
                .then(blob => {
                    const img = new Image();
                    img.onload = () => {
                        // Set canvas size to the image size
                        canvas.width = img.width;
                        canvas.height = img.height;

                        // Clear the canvas
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // Draw the image with its original size
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        
                        // Draw points and lines on the image
                        drawPointsAndLines();
                    };
                    img.src = URL.createObjectURL(blob);
                });
        }

        function drawPointsAndLines() {
            points.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();

                if (index > 0) {
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 2;
                    ctx.moveTo(points[index - 1].x, points[index - 1].y);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                }
            });

            if (points.length > 1 && isNearFirstPoint(points[points.length - 1], points[0])) {
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.moveTo(points[points.length - 1].x, points[points.length - 1].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                drawingMode = false;  // Stop drawing if closed
                sendToggleDraw(false);
            }
        }

        function isNearFirstPoint(lastPoint, firstPoint) {
            const distance = Math.sqrt(Math.pow(lastPoint.x - firstPoint.x, 2) + Math.pow(lastPoint.y - firstPoint.y, 2));
            return distance < threshold;
        }

        canvas.addEventListener('click', (event) => {
            if (drawingMode) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                points.push({ x: x, y: y });

                // Vẽ điểm và đường thẳng ngay lập tức sau khi nhấp
                drawPointsAndLines();

                // Gửi điểm lên server
                fetch('/draw', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ points: [{ x: x, y: y }] })
                });
            }
        });

        document.getElementById('zoom-in').addEventListener('click', () => {
            fetch('/zoom', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ zoom_in: true })
            }).then(loadImage);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            fetch('/zoom', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ zoom_in: false })
            }).then(loadImage);
        });

        document.getElementById('draw').addEventListener('click', () => {
            drawingMode = true;
            sendToggleDraw(true);
        });

        document.getElementById('end-draw').addEventListener('click', () => {
            drawingMode = false;
            sendToggleDraw(false);
        });

        function sendToggleDraw(drawingMode) {
            fetch('/toggle-draw', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ drawing_mode: drawingMode })
            }).then(() => {
                if (!drawingMode) points = [];  // Clear points when drawing ends
            });
        }

        loadImage();
    </script>
</body>
</html>
