<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <style>
        canvas {
            /* Xóa khung viền của canvas */
            border: none;
            display: block;
            margin: 0 5px;
        }
        #end-draw{
            display: none;
        }
        #content{
            display: flex;
            flex-direction: row;
        }
        #right-bar{
            margin-left: 5px;
            border: 1px solid #000;
            width: 20vw;
        }
        #object-header{
            text-align: center;
        }
        #btn{
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            margin-top: 10px;
        }
        .btn-child{
            padding: 5px;
            background-color: #333;
            color: #fff;
            border: 1px solid #000;
        }
        .btn-child:hover{
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Welcome, {{ user_id }}</h1>

    <div>
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <button id="draw">Draw</button>
        <button id="end-draw">End Draw</button>
        <button id="delete-last">Delete Last</button>
        <button id="delete-polygon">Delete Polygon</button>
    </div>

    <div id="content">
        <canvas id="imageCanvas"></canvas>
    
        <div id="right-bar">
            <div id="btn">
                <div class="btn-child" id="req">Request</div>
                <div class="btn-child" id="submit">Submit</div>
            </div>
            <h2 id="object-header">Objects</h2>
            <ul id="object-list"></ul>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('imageCanvas');
        const objectList = document.getElementById('object-list');
        const ctx = canvas.getContext('2d');
        let drawingMode = false;
        let points = [];
        const threshold = 10;  // Adjust threshold value as needed
        let deleteMode = false;
        let polygons = []; 

        loadClasses();
        function loadImage() {
            fetch('/get-image')
                .then(response => response.blob())
                .then(blob => {
                    const img = new Image();
                    img.onload = () => {
                        // Set canvas size to the image size
                        canvas.width = img.width;
                        canvas.height = img.height;

                        // Clear the canvas
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // Draw the image with its original size
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        
                        // Draw points and lines on the image
                        drawPointsAndLines();
                    };
                    img.src = URL.createObjectURL(blob);
                });
        }

        let selectedLabel = null;  // Store the currently selected label        
        // Load classes and handle checkbox selection
        function loadClasses() {
            fetch('/static/config.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(config => {
                    console.log(config);
                    const classes = config.classes;
                    objectList.innerHTML = '';              

                    classes.forEach((className, index) => {
                        const listItem = document.createElement('li');      

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `class-${index}`;
                        checkbox.value = className;             

                        const label = document.createElement('label');
                        label.htmlFor = `class-${index}`;
                        label.innerText = className;                

                        checkbox.addEventListener('change', (event) => {
                            if (event.target.checked) {
                                document.querySelectorAll('#object-list input[type="checkbox"]').forEach(box => {
                                    if (box !== event.target) {
                                        box.checked = false;
                                    }
                                });
                                selectedLabel = className;  // Set the selected label when checked
                            } else {
                                selectedLabel = null;  // No label selected if unchecked
                            }
                        });             

                        listItem.appendChild(checkbox);
                        listItem.appendChild(label);
                        objectList.appendChild(listItem);
                    });
                })
                .catch(error => {
                    console.error('Error loading classes:', error);
                });
        }

        function drawPointsAndLines() {
            points.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();

                if (index > 0) {
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 2;
                    ctx.moveTo(points[index - 1].x, points[index - 1].y);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                }
            });

            if (points.length > 1 && isNearFirstPoint(points[points.length - 1], points[0])) {
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.moveTo(points[points.length - 1].x, points[points.length - 1].y);
                ctx.lineTo(points[0].x, points[0].y);
                ctx.stroke();
                drawingMode = false;  // Stop drawing if closed
                sendToggleDraw(false);
            }
        }

        function isNearFirstPoint(lastPoint, firstPoint) {
            const distance = Math.sqrt(Math.pow(lastPoint.x - firstPoint.x, 2) + Math.pow(lastPoint.y - firstPoint.y, 2));
            return distance < threshold;
        }

        canvas.addEventListener('click', (event) => {
            if (drawingMode) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                points.push({ x: x, y: y });

                // Vẽ điểm và đường thẳng ngay lập tức sau khi nhấp
                drawPointsAndLines();

                // Gửi điểm lên server
                fetch('/draw', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ points: [{ x: x, y: y }], label: selectedLabel})
                });
            }
        });

        

        document.getElementById('submit').addEventListener('click', () => {
            loadImage();
            fetch('/submit-polygons', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
            })
            .then(response => {
                if (response.ok) {
                    alert('Polygons saved successfully!');
                } else {
                    alert('Failed to save polygons.');
                }
            });
        });


        document.getElementById('zoom-in').addEventListener('click', () => {
            fetch('/zoom', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ zoom_in: true })
            }).then(loadImage);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            fetch('/zoom', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ zoom_in: false })
            }).then(loadImage);
        });

        document.getElementById('draw').addEventListener('click', () => {
            drawingMode = true;
            sendToggleDraw(true);
        });

        document.getElementById('delete-last').addEventListener('click', () => {
            if (points.length > 0) {
                points.pop();
                fetch('/delete-last', { method: 'POST' })
                    .then(() => {
                        // Clear the canvas and reload the image
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        fetch('/get-image')
                            .then(response => response.blob())
                            .then(blob => {
                                const img = new Image();
                                img.onload = () => {
                                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                    drawPointsAndLines();  // Redraw the remaining points
                                };
                                img.src = URL.createObjectURL(blob);
                            });
                    });
            }
        });

        document.getElementById('end-draw').addEventListener('click', () => {
            drawingMode = false;
            sendToggleDraw(false);
        });

        function sendToggleDraw(drawingMode) {
            if (!selectedLabel && drawingMode) {
                alert('Please select a label before drawing!');
                return;
            }       
            fetch('/toggle-draw', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ drawing_mode: drawingMode, label: selectedLabel })  // Include the selected label
            }).then(() => {
                if (!drawingMode) points = [];  // Clear points when drawing ends
            });
        }
        loadImage();

        //  Delete mode  
        let selectedPolygonIndex = null;

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'e') {
                deleteMode = !deleteMode;
                alert(deleteMode ? 'Delete Mode Enabled' : 'Delete Mode Disabled');
            }
        });

        canvas.addEventListener('click', function(event) {
            if(!deleteMode) return;

            const rect = event.target.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            fetch('/check-point', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    x: clickX,
                    y: clickY
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.inside) {
                    console.log("Point inside polygon at index:", data.polygon_index);
                    selectedPolygonIndex = data.polygon_index;

                } else {
                    console.log("Point outside of all polygons");
                }
            });
        });

        document.getElementById('delete-polygon').addEventListener('click', () => {
            fetch('/delete-polygon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ polygon_index: selectedPolygonIndex }) // Replace with actual selected index
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Polygon deleted successfully');
                    selectedPolygonIndex = null;
                    deleteMode = false
                    loadImage();
                } else {
                    alert('Delete Mode is turn off');
                }
            });
        });
    </script>
</body>
</html>